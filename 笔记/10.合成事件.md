基于React内部的处理，如果我们给合成事件绑定一个“普通函数”，当事件行为触发，绑定的函数执行；方法中的this会是undefined
解决方案：

- 基于JS中的bind方法：预先处理函数中的this和实参
- 推荐：把绑定的函数设置为“箭头函数”，让其使用上下文中的this，也就是我们的实例

```js
class Demo2 extends React.Component {
  
  handler1() {
    console.log(this);  // undefined
  }
  
  handler2() {
    console.log(this);  // 类的实例
  }

  handler3 = (ev) => {
    console.log(this); // 类的实例
  console.log(ev);  // SyntheticBaseEvent 合成事件对象，React内部经过特殊处理，把各个浏览器的事件对象统一化后，构建的一个事件对象
}

  render() {
    return <div>
      <button onClick={this.handler1}>按钮1</button>
      <button onClick={this.handler2.bind(this)}>按钮2</button>
      <button onClick={this.handler3}>按钮3</button>
    </div>
  }
}

```


合成事件对象：我们在React合成事件触发的时候，也可以获取到事件对象，只不过此对象是合成事件对象（React内部经过特殊处理，把各个浏览器的事件对象统一化后，构建的一个事件对象）
合成事件对象中，也包含了浏览器内置事件对象中的一些属性和方法（常用的基本都有）
- clientX 、clientY
- pageX 、pageY
- target
- type
- preventDefault
- stopPropagation
- ...
- nativeEvent:基于这个属性，可以获取浏览器内置的事件对象


`bind`在React事件绑定中的运用：

- 绑定的方法是一个普通函数，需要改变函数中的this是实例，此时需要用到bind
- 想给函数传递指定的实参，可以基于bind预先处理，bind会把事件对象以最后一个实参传递给函数   


事件具备传播机制，例如：当我们触发inner的点击行为的时候：

- 第一步：从最外层向最里层逐一查找（捕获阶段：分析出路径）
- 第二步：把事件源（点击的这个元素）的点击行为触发（目标阶段）
- 第三步：按照捕获阶段分析出来的路径，从里到外，把每一个元素的点击行为也触发！！（冒泡阶段）

event.stopPropagation阻止事件传播（包括捕获和冒泡）
event.stopImmediatePropagation:也是阻止事件传播，只不过它可以把当前元素绑定的其他方法（同级的），如果还未执行，也不会让其再执行了！


事件委托：利用事件的传播机制，实现的一套事件绑定的处理方案
例如：一个容器中，有很多元素都要再点击的时候做一些事情
传统方案：首先获取需要操作的元素，然后逐一做事件绑定
事件委托：只需要给容器做一个事件绑定，点击内部的任何元素，根据事件的冒泡传播机制，都会让容器的点击事件也触发；我们可以根据事件源，做不同的事情
优势：

- 提高JS代码运行的性能，并且把处理的逻辑都集中在一起
- 某些需求必须基于事件委托处理，例如：除了点击xxx外，点击其余的任何东西，做xxx
- 给动态绑定的元素添加事件绑定

限制：

- 当前操作的事件必须支持冒泡传播机制才可以
例如：mouseenter 、mouseleave等事件是没有冒泡传播机制的
- 如果单独做的事件绑定中，做了事件传播机制的阻止，那么事件委托中的操作也不会生效