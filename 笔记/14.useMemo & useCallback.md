useMemo & useCallback

let xx = useMemo(callback, [dependencies])

- 第一次渲染组件的时候，callback会执行
- 后期只有依赖的状态值发生改变，callback才会再执行
- 每一次会把callback执行的返回结果赋值给xx
- useMemo具备”计算缓存“，在依赖的状态值没有发生改变，callback没有触发执行的时候，xx获取的是上一次计算出来的结果
- 如果函数组件中，有消耗性能、时间的计算操作，尽可能用useMemo缓存起来，设置对应的依赖
- 这样可以保证，当非依赖的状态发生改变，不会去处理一些没必要的操作，提高组件更新的速度



函数组件的每一次更新，都是把函数重新执行

- 产生一个新的闭包
- 在闭包中所有创建函数的操作，都会重新创建新的堆内存

```jsx
const xxx = useCallback(callback, [dependencies])
```

- 组件第一次渲染，useCallback执行，创建一个”callback“函数，赋值给xxx
- 组件后续每一次更新，判断依赖的状态值是否改变，如果改变，则重新创建新的函数堆，赋值给xxx；但是如果依赖的状态没有更新或者没有设置依赖，则xxx获取的一直是第一次创建的函数堆，不会创建新的函数出来
- 或者说，基于useCallback，可以始终获取第一次创建函数的堆内存地址
- useCallback虽然减少了堆内存的开辟，但是本身useCallback也有自己的处理逻辑和缓存机制，这个也消耗时间



诉求：当父组件更新的时候，因为传递给子组件的属性仅仅是一个函数，所以不想再让子组件也跟着更新了！

1. 传递给子组件的属性（函数），每一次需要是相同的堆内存地址，基于useCallback处理
2. 在子组件内部也要做一个处理，验证父组件传递的属性是否发生改变，如果没有变化，则让子组件不能更新，有变化才需要更新，继承React.PureComponent即可（shouldComponentUpdate中对新老属性做了浅比较）函数组件时基于React.memo函数，对新老传递的属性做比较，如果不一致，才会把函数组件执行，如果一致，则不让子组件更新